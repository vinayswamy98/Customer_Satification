import pandas as pd
import anthropic
import os
from typing import Dict, List, Tuple
import json

class ThemeMapper:
“””
Maps new data to existing global themes and sub-themes using Claude LLM.
“””

```
def __init__(self, api_key: str = None):
    """
    Initialize the ThemeMapper with Anthropic API key.
    
    Args:
        api_key: Anthropic API key (if None, uses ANTHROPIC_API_KEY env variable)
    """
    self.client = anthropic.Anthropic(api_key=api_key or os.environ.get("ANTHROPIC_API_KEY"))
    self.theme_structure = None
    
def prepare_theme_structure(self, df: pd.DataFrame, 
                           global_theme_col: str = 'global_theme',
                           global_desc_col: str = 'global_description',
                           sub_theme_col: str = 'sub_theme',
                           sub_desc_col: str = 'sub_theme_description',
                           separator: str = '|') -> Dict:
    """
    Parse the dataframe and create a structured theme taxonomy.
    
    Args:
        df: DataFrame with theme information
        global_theme_col: Column name for global themes
        global_desc_col: Column name for global theme descriptions
        sub_theme_col: Column name for sub-themes (pipe-separated)
        sub_desc_col: Column name for sub-theme descriptions (pipe-separated)
        separator: Separator used in sub-theme columns
        
    Returns:
        Dictionary with structured theme hierarchy
    """
    theme_dict = {}
    
    for _, row in df.iterrows():
        global_theme = row[global_theme_col]
        global_desc = row[global_desc_col]
        
        # Parse sub-themes and descriptions
        sub_themes = str(row[sub_theme_col]).split(separator) if pd.notna(row[sub_theme_col]) else []
        sub_descs = str(row[sub_desc_col]).split(separator) if pd.notna(row[sub_desc_col]) else []
        
        # Clean whitespace
        sub_themes = [s.strip() for s in sub_themes if s.strip()]
        sub_descs = [s.strip() for s in sub_descs if s.strip()]
        
        # Create sub-theme mapping
        sub_theme_dict = {}
        for i, sub_theme in enumerate(sub_themes):
            sub_theme_dict[sub_theme] = sub_descs[i] if i < len(sub_descs) else ""
        
        theme_dict[global_theme] = {
            'description': global_desc,
            'sub_themes': sub_theme_dict
        }
    
    self.theme_structure = theme_dict
    return theme_dict

def create_theme_prompt(self) -> str:
    """
    Create a formatted string representation of the theme structure for the LLM.
    
    Returns:
        Formatted string with theme taxonomy
    """
    if not self.theme_structure:
        raise ValueError("Theme structure not initialized. Call prepare_theme_structure() first.")
    
    prompt_parts = ["Here is the theme taxonomy:\n"]
    
    for global_theme, details in self.theme_structure.items():
        prompt_parts.append(f"\n**GLOBAL THEME: {global_theme}**")
        prompt_parts.append(f"Description: {details['description']}")
        prompt_parts.append("\nSub-themes:")
        
        for sub_theme, sub_desc in details['sub_themes'].items():
            prompt_parts.append(f"  - {sub_theme}: {sub_desc}")
    
    return "\n".join(prompt_parts)

def map_single_item(self, summary: str, keywords: str = None, 
                   model: str = "claude-sonnet-4-20250514") -> Dict:
    """
    Map a single item to the most appropriate global theme and sub-theme.
    
    Args:
        summary: Text summary of the item
        keywords: Optional keywords associated with the item
        model: Claude model to use
        
    Returns:
        Dictionary with global_theme, sub_theme, confidence, and reasoning
    """
    theme_taxonomy = self.create_theme_prompt()
    
    # Build the user message
    user_message = f"""Please analyze the following content and map it to the most appropriate Global Theme and Sub-Theme from the taxonomy provided.
```

CONTENT TO CLASSIFY:
Summary: {summary}
{f’Keywords: {keywords}’ if keywords else ‘’}

{theme_taxonomy}

Analyze the content carefully and:

1. Identify the most relevant Global Theme
1. Within that Global Theme, identify the most relevant Sub-Theme
1. Provide a confidence score (0-100) for your classification
1. Briefly explain your reasoning

Return your response in this JSON format:
{{
“global_theme”: “selected global theme”,
“sub_theme”: “selected sub-theme”,
“confidence”: 85,
“reasoning”: “brief explanation of why this classification was chosen”
}}”””

```
    try:
        message = self.client.messages.create(
            model=model,
            max_tokens=1024,
            messages=[
                {"role": "user", "content": user_message}
            ]
        )
        
        # Extract JSON from response
        response_text = message.content[0].text
        
        # Try to parse JSON from the response
        # Handle cases where response might include markdown code blocks
        if "```json" in response_text:
            json_str = response_text.split("```json")[1].split("```")[0].strip()
        elif "```" in response_text:
            json_str = response_text.split("```")[1].split("```")[0].strip()
        else:
            json_str = response_text.strip()
        
        result = json.loads(json_str)
        return result
        
    except Exception as e:
        return {
            "global_theme": None,
            "sub_theme": None,
            "confidence": 0,
            "reasoning": f"Error during classification: {str(e)}"
        }

def map_batch(self, new_data_df: pd.DataFrame,
              summary_col: str = 'summary',
              keywords_col: str = 'keywords',
              model: str = "claude-sonnet-4-20250514") -> pd.DataFrame:
    """
    Map a batch of new items to themes.
    
    Args:
        new_data_df: DataFrame with new items to classify
        summary_col: Column name for summary text
        keywords_col: Column name for keywords (optional)
        model: Claude model to use
        
    Returns:
        DataFrame with added columns: mapped_global_theme, mapped_sub_theme, 
        confidence, reasoning
    """
    results = []
    
    for idx, row in new_data_df.iterrows():
        summary = row[summary_col]
        keywords = row.get(keywords_col, None) if keywords_col in new_data_df.columns else None
        
        print(f"Processing item {idx + 1}/{len(new_data_df)}...")
        result = self.map_single_item(summary, keywords, model)
        results.append(result)
    
    # Add results to dataframe
    result_df = new_data_df.copy()
    result_df['mapped_global_theme'] = [r['global_theme'] for r in results]
    result_df['mapped_sub_theme'] = [r['sub_theme'] for r in results]
    result_df['confidence'] = [r['confidence'] for r in results]
    result_df['reasoning'] = [r['reasoning'] for r in results]
    
    return result_df
```

# Example usage:

if **name** == “**main**”:
# Example theme structure dataframe
theme_df = pd.DataFrame({
‘global_theme’: [‘Technology’, ‘Healthcare’, ‘Finance’],
‘global_description’: [
‘Topics related to technology, software, and digital innovation’,
‘Topics related to health, medicine, and wellness’,
‘Topics related to financial markets, banking, and investments’
],
‘sub_theme’: [
‘Artificial Intelligence | Cloud Computing | Cybersecurity’,
‘Medical Research | Patient Care | Pharmaceuticals’,
‘Stock Markets | Banking Services | Cryptocurrency’
],
‘sub_theme_description’: [
‘AI and machine learning applications | Cloud infrastructure and services | Security and data protection’,
‘Clinical trials and medical studies | Healthcare delivery and treatment | Drug development and distribution’,
‘Equity markets and trading | Retail and commercial banking | Digital currencies and blockchain’
]
})

```
# Initialize mapper
mapper = ThemeMapper()
mapper.prepare_theme_structure(theme_df)

# Example new data to classify
new_data = pd.DataFrame({
    'summary': [
        'Our new deep learning model achieved 95% accuracy in image recognition tasks',
        'Clinical trial shows promising results for new cancer treatment',
        'Bitcoin price surges amid institutional adoption'
    ],
    'keywords': [
        'machine learning, neural networks, computer vision',
        'oncology, clinical trial, pharmaceutical',
        'crypto, digital assets, blockchain'
    ]
})

# Map new data to themes
mapped_data = mapper.map_batch(new_data)
print(mapped_data[['summary', 'mapped_global_theme', 'mapped_sub_theme', 'confidence']])
```